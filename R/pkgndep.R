# == title
# Number of Dependency Packages
#
# == param
# -pkg Package name or the path of the package.
# -verbose Whether print messages. 
#
# == details
# For each package listed in the "Depends", "Imports" and "Suggests" (or also "Enhances") fields
# in the DESCRIPTION file, this function opens a new R session, loads the package
# and counts the number of namespaces that are loaded.
#
# == value
# A ``pkgndep`` object.
#
# == example
# \donttest{
# x = pkgndep("ComplexHeatmap")
# }
# # The `x` variable generated by `pkgndep()` is already saved in this package.
# x = readRDS(system.file("extdata", "ComplexHeatmap_dep.rds", package = "pkgndep"))
# x
# plot(x)
# 
pkgndep = function(pkg, verbose = TRUE) {

	if(verbose) {
		cat(blue(GetoptLong::qq("========== checking @{pkg} ==========\n")))
	}
	if(file.exists(pkg)) {
		x = read.dcf(paste0(pkg, "/DESCRIPTION"))
		x = as.data.frame(x)
	} else {
		if(!pkg_exists(pkg)) {
			stop(paste0("Package '", pkg, "' cannot be found."))
		}
		x = packageDescription(pkg)
	}

	if(is.null(x$Depends)) {
		depends = character(0)
	} else {
		depends = x$Depends
		depends = gsub("\\s*\\(.*?\\)", "", depends)
		depends = strsplit(depends, "\\s*,\\s*")[[1]]
		depends = depends[depends != "R"]
	}

	if(is.null(x$Imports)) {
		imports = character(0)
	} else {
		imports = x$Imports
		imports = gsub("\\s*\\(.*?\\)", "", imports)
		imports = strsplit(imports, "\\s*,\\s*")[[1]]

		imports = setdiff(imports, depends)
	}

	if(is.null(x$Suggests)) {
		suggests = character(0)
	} else {
		suggests = x$Suggests
		suggests = gsub("\\s*\\(.*?\\)", "", suggests)
		suggests = strsplit(suggests, "\\s*,\\s*")[[1]]
	}

	if(is.null(x$Enhances)) {
		enhances = character(0)
		has_enhances = FALSE
	} else {
		enhances = x$Enhances
		enhances = gsub("\\s*\\(.*?\\)", "", enhances)
		enhances = strsplit(enhances, "\\s*,\\s*")[[1]]
		has_enhances = TRUE
	}

	suggests = c(suggests, enhances)

	dep_lt = lapply(depends, dep, verbose)
	names(dep_lt) = depends
	imp_lt = lapply(imports, dep, verbose)
	names(imp_lt) = imports
	sug_lt = lapply(suggests, dep, verbose)
	names(sug_lt) = suggests

	all_pkg = c(depends, imports, suggests)

	if(length(all_pkg) == 0) {
		obj = list(
			package = x$Package,
			version = x$Version,
			mat = matrix(nrow = 0, ncol = 0), 
			pkg_category = character(0),
			which_enhances = logical(0),
			pkg_available = logical(0),
			n_by_depends_imports = 0,
			n_by_all = 0,
			bioc = !is.null(x$biocViews),
			df_imports = NULL
		)

		class(obj) = "pkgndep"
		return(obj)
	}

	dep_lt2 = dep_lt[!sapply(dep_lt, is.null)]
	imp_lt2 = imp_lt[!sapply(imp_lt, is.null)]
	sug_lt2 = sug_lt[!sapply(sug_lt, is.null)]

	all_pkg_dep = unique(unlist(c(lapply(dep_lt2, function(x) x[, 1]), 
		                          lapply(imp_lt2, function(x) x[, 1]), 
		                          lapply(sug_lt2, function(x) x[, 1]))))

	m = matrix(NA, nrow = length(all_pkg), ncol = length(all_pkg_dep), dimnames = list(all_pkg, all_pkg_dep))
	tm = numeric(nrow(m))
	names(tm) = rownames(m)
	for(nm in names(dep_lt2)) {
		y = structure(dep_lt2[[nm]][, 2], names = dep_lt2[[nm]][, 1])
		m[nm, names(y)] = y
		tm[nm] = dep_lt2[[nm]][, 3][1]
	}
	for(nm in names(imp_lt2)) {
		y = structure(imp_lt2[[nm]][, 2], names = imp_lt2[[nm]][, 1])
		m[nm, names(y)] = y
		tm[nm] = imp_lt2[[nm]][, 3][1]
	}
	for(nm in names(sug_lt2)) {
		y = structure(sug_lt2[[nm]][, 2], names = sug_lt2[[nm]][, 1])
		m[nm, names(y)] = y
		tm[nm] = sug_lt2[[nm]][, 3][1]
	}

	if(has_enhances) {
		pkg_category = c(rep("Depends", length(dep_lt)), rep("Imports", length(imports)), rep("Suggests or\nEnhances", length(suggests)))
	} else {
		pkg_category = c(rep("Depends", length(dep_lt)), rep("Imports", length(imports)), rep("Suggests", length(suggests)))
	}
	names(pkg_category) = rownames(m)
	pkg_available = !sapply(c(dep_lt, imp_lt, sug_lt), is.null)

	od = order(pkg_category, apply(m, 1, function(x) sum(!is.na(x))))
	m = m[od, , drop = FALSE]
	pkg_category = pkg_category[od]
	pkg_available = pkg_available[od]
	tm = tm[od]

	n_total1 = length(unique(c(rownames(m), colnames(m))))
	l1 = pkg_category %in% c("Depends", "Imports")
	l2 = apply(m[l1, , drop = FALSE], 2, function(x) any(!is.na(x)))
	n_total2 = length(unique(unlist(dimnames(m[l1, l2, drop = FALSE]))))
	
	obj = list(
		package = x$Package,
		version = x$Version,
		mat = m, 
		pkg_category = pkg_category,
		which_imported = pkg_category %in% c("Depends", "Imports"),
		which_enhanced = rownames(m) %in% enhances,
		pkg_available = pkg_available,
		loading_time = tm,
		n_by_depends_imports = n_total2,
		n_by_all = n_total1,
		bioc = !is.null(x$biocViews)
	)

	df_imports = matrix(0, nrow = nrow(m), ncol = 3)
	colnames(df_imports) = c("imports", "importMethods", "importClasses")
	rownames(df_imports) = rownames(m)

	lt_imports = parse_imports_from_namespace(x$Package)
	if(!is.null(lt_imports)) {
		if(length(lt_imports$n_imports)) {
			lt_imports$n_imports = lt_imports$n_imports[intersect(names(lt_imports$n_imports), rownames(m))]
			df_imports[names(lt_imports$n_imports), "imports"] = lt_imports$n_imports
		}
		if(length(lt_imports$n_import_methods)) {
			lt_imports$n_import_methods = lt_imports$n_import_methods[intersect(names(lt_imports$n_import_methods), rownames(m))]
			df_imports[names(lt_imports$n_import_methods), "importMethods"] = lt_imports$n_import_methods
		}
		if(length(lt_imports$n_import_classes)) {
			lt_imports$n_import_classes = lt_imports$n_import_classes[intersect(names(lt_imports$n_import_classes), rownames(m))]
			df_imports[names(lt_imports$n_import_classes), "importClasses"] = lt_imports$n_import_classes
		}
	}

	not_used = setdiff(rownames(df_imports), c(unlist(lapply(lt_imports, names)), rownames(m)[!obj$which_imported]))
	if(length(not_used)) {
		df_imports[not_used, 1] = -Inf
	}
	obj$df_imports = df_imports

	class(obj) = "pkgndep"

	obj$heaviness = heaviness(obj)
	return(obj)
}

pkg_exists = function(x) {
	system.file(package = x) != ""
}

parse_imports_from_namespace = function(x) {
	lib_dir = dirname(system.file(package = x))
	if(packageHasNamespace(x, lib_dir)) {
		ns_data = parseNamespaceFile(x, lib_dir)

		lt = ns_data$imports
		if(length(lt)) {
			lt1 = lt[!sapply(lt, is.list)]
			lt2 = lt[sapply(lt, is.list)]
			n_imports = tapply(seq_along(lt2), unlist(sapply(lt2, function(x) x[1])), 
				function(x) unique(unlist(lapply(lt2[x], function(y) y[2]))))
			n_imports = sapply(n_imports, length)
			sign = tapply(seq_along(lt2), unlist(sapply(lt2, function(x) x[1])), 
				function(x) unique(unlist(lapply(lt2[x], function(y) names(y)[2]))))
			sign = sapply(sign, function(x) ifelse(identical(x, "except"), -1, 1))
			n_imports = n_imports * sign
		} else {
			n_imports = NULL                
		}

		lt = ns_data$importMethods
		if(length(lt)) {
			lt1 = lt[!sapply(lt, is.list)]
			lt2 = lt[sapply(lt, is.list)]
			n_import_methods = tapply(seq_along(lt2), unlist(sapply(lt2, function(x) x[1])), 
				function(x) unique(unlist(lapply(lt2[x], function(y) y[2]))))
			n_import_methods = sapply(n_import_methods, length)
		} else {
			n_import_methods = NULL
		}


		lt = ns_data$importClasses
		if(length(lt)) {
			lt1 = lt[!sapply(lt, is.list)]
			lt2 = lt[sapply(lt, is.list)]
			n_import_classes = tapply(seq_along(lt2), unlist(sapply(lt2, function(x) x[1])), 
				function(x) unique(unlist(lapply(lt2[x], function(y) y[2]))))
			n_import_classes = sapply(n_import_classes, length)
		} else {
			n_import_classes = NULL
		}

		list(n_imports = n_imports, n_import_methods = n_import_methods, n_import_classes = n_import_classes)
	} else {
		NULL
	}
}

# == title
# Print method
#
# == param
# -x An object from `pkgndep`.
# -... Other arguments.
#
# == value
# No value is returned.
#
# == example
# # See examples in `pkgndep()`.
#
print.pkgndep = function(x, ...) {
	GetoptLong::qqcat("@{x$package} version @{x$version}\n")
	GetoptLong::qqcat("@{x$n_by_depends_imports} namespaces loaded if only loading packages in Depends and Imports\n")
	if(any(x$which_enhanced)) {
		GetoptLong::qqcat("@{x$n_by_all} namespaces loaded after loading all packages in Depends, Imports and Suggests/Enhances\n")
	} else {
		GetoptLong::qqcat("@{x$n_by_all} namespaces loaded after loading all packages in Depends, Imports and Suggests\n")
	}
}

# == title
# Loaded namespaces
#
# == param
# -x An object from `pkgndep`.
# -include_suggests Whether to include the namespaces that are loaded if also loading packages from "Suggests"/"Enhances" field.
#
# == value
# A vector of namespace names.
#
loaded_namespaces = function(x, include_suggests = FALSE) {
	m = x$m
	if(include_suggests) {
		sort(unique(c(rownames(m), colnames(m))))
	} else {
		l1 = x$pkg_category %in% c("Depends", "Imports")
		l2 = apply(m[l1, , drop = FALSE], 2, function(x) any(!is.na(x)))
		sort(unique(unlist(dimnames(m[l1, l2, drop = FALSE]))))
	}
}

# == title
# Unavailable packages
#
# == param
# -x An object from `pkgndep`.
#
# == details
# It lists the packages that are not installed in the "Suggests" field.
#
# == value
# A vector of package names.
#
unavailable_packages = function(x) {
	sort(rownames(x$mat)[!x$pkg_available])
}

pkg_category = function(x) {
	x = x$pkg_category
	x[x$which_enhanced] = "Enrhances"
	x
}
