# == title
# Number of Dependency Packages
#
# == param
# -pkg Package name or the path of the package.
# -verbose Whether print messages. 
#
# == details
# For each package listed in the "Depends", "Imports" and "Suggests" (or also "Enhances") fields
# in the DESCRIPTION file, this function opens a new R session, loads the package
# and counts the number of namespaces that are loaded.
#
# == value
# A ``pkgndep`` object.
#
# == example
# \donttest{
# x = pkgndep("ComplexHeatmap")
# }
# # The `x` variable generated by `pkgndep()` is already saved in this package.
# x = readRDS(system.file("extdata", "x.rds", package = "pkgndep"))
# x
# plot(x)
# 
pkgndep = function(pkg, verbose = TRUE) {

	if(verbose) {
		cat(blue(GetoptLong::qq("========== checking @{pkg} ==========\n")))
	}
	if(file.exists(pkg)) {
		x = read.dcf(paste0(pkg, "/DESCRIPTION"))
		x = as.data.frame(x)
	} else {
		if(!pkg_exists(pkg)) {
			stop(paste0("Package '", pkg, "' cannot be found."))
		}
		x = packageDescription(pkg)
	}

	if(is.null(x$Depends)) {
		depends = character(0)
	} else {
		depends = x$Depends
		depends = gsub("\\s*\\(.*?\\)", "", depends)
		depends = strsplit(depends, "\\s*,\\s*")[[1]]
		depends = depends[depends != "R"]
	}

	if(is.null(x$Imports)) {
		imports = character(0)
	} else {
		imports = x$Imports
		imports = gsub("\\s*\\(.*?\\)", "", imports)
		imports = strsplit(imports, "\\s*,\\s*")[[1]]

		imports = setdiff(imports, depends)
	}

	if(is.null(x$Suggests)) {
		suggests = character(0)
	} else {
		suggests = x$Suggests
		suggests = gsub("\\s*\\(.*?\\)", "", suggests)
		suggests = strsplit(suggests, "\\s*,\\s*")[[1]]
	}

	if(is.null(x$Enhances)) {
		enhances = character(0)
		has_enhances = FALSE
	} else {
		enhances = x$Enhances
		enhances = gsub("\\s*\\(.*?\\)", "", enhances)
		enhances = strsplit(enhances, "\\s*,\\s*")[[1]]
		has_enhances = TRUE
	}

	suggests = c(suggests, enhances)

	dep_lt = lapply(depends, dep, verbose)
	names(dep_lt) = depends
	imp_lt = lapply(imports, dep, verbose)
	names(imp_lt) = imports
	sug_lt = lapply(suggests, dep, verbose)
	names(sug_lt) = suggests

	all_pkg = c(depends, imports, suggests)

	if(length(all_pkg) == 0) {
		obj = list(
			package = x$Package,
			version = x$Version,
			mat = matrix(nrow = 0, ncol = 0), 
			pkg_category = character(0),
			pkg_available = logical(0),
			n_by_depends_imports = 0,
			n_by_all = 0,
			bioc = !is.null(x$biocViews),
			df_imports = NULL
		)

		class(obj) = "pkgndep"
		return(obj)
	}

	dep_lt2 = dep_lt[!sapply(dep_lt, is.null)]
	imp_lt2 = imp_lt[!sapply(imp_lt, is.null)]
	sug_lt2 = sug_lt[!sapply(sug_lt, is.null)]

	all_pkg_dep = unique(unlist(c(lapply(dep_lt2, function(x) x[, 1]), 
		                          lapply(imp_lt2, function(x) x[, 1]), 
		                          lapply(sug_lt2, function(x) x[, 1]))))

	m = matrix(NA, nrow = length(all_pkg), ncol = length(all_pkg_dep), dimnames = list(all_pkg, all_pkg_dep))
	tm = numeric(nrow(m))
	names(tm) = rownames(m)
	for(nm in names(dep_lt2)) {
		y = structure(dep_lt2[[nm]][, 2], names = dep_lt2[[nm]][, 1])
		m[nm, names(y)] = y
		tm[nm] = dep_lt2[[nm]][, 3][1]
	}
	for(nm in names(imp_lt2)) {
		y = structure(imp_lt2[[nm]][, 2], names = imp_lt2[[nm]][, 1])
		m[nm, names(y)] = y
		tm[nm] = imp_lt2[[nm]][, 3][1]
	}
	for(nm in names(sug_lt2)) {
		y = structure(sug_lt2[[nm]][, 2], names = sug_lt2[[nm]][, 1])
		m[nm, names(y)] = y
		tm[nm] = sug_lt2[[nm]][, 3][1]
	}

	if(has_enhances) {
		pkg_category = c(rep("Depends", length(dep_lt)), rep("Imports", length(imports)), rep("Suggests or\nEnhances", length(suggests)))
	} else {
		pkg_category = c(rep("Depends", length(dep_lt)), rep("Imports", length(imports)), rep("Suggests", length(suggests)))
	}
	names(pkg_category) = rownames(m)
	pkg_available = !sapply(c(dep_lt, imp_lt, sug_lt), is.null)

	od = order(pkg_category, apply(m, 1, function(x) sum(!is.na(x))))
	m = m[od, , drop = FALSE]
	pkg_category = pkg_category[od]
	pkg_available = pkg_available[od]
	tm = tm[od]

	n_total1 = length(unique(c(rownames(m), colnames(m))))
	l1 = pkg_category %in% c("Depends", "Imports")
	l2 = apply(m[l1, , drop = FALSE], 2, function(x) any(!is.na(x)))
	n_total2 = length(unique(unlist(dimnames(m[l1, l2, drop = FALSE]))))
	
	obj = list(
		package = x$Package,
		version = x$Version,
		mat = m, 
		pkg_category = pkg_category,
		pkg_available = pkg_available,
		loading_time = tm,
		n_by_depends_imports = n_total2,
		n_by_all = n_total1,
		bioc = !is.null(x$biocViews)
	)

	df_imports = matrix(0, nrow = nrow(m), ncol = 3)
	colnames(df_imports) = c("import", "importMethods", "importClasses")
	rownames(df_imports) = rownames(m)

	lt_imports = parse_imports_from_namespace(x$Package)
	if(!is.null(lt_imports)) {
		if(length(lt_imports$n_imports)) {
			lt_imports$n_imports = lt_imports$n_imports[intersect(names(lt_imports$n_imports), rownames(m))]
			df_imports[names(lt_imports$n_imports), "import"] = lt_imports$n_imports
		}
		if(length(lt_imports$n_import_methods)) {
			lt_imports$n_import_methods = lt_imports$n_import_methods[intersect(names(lt_imports$n_import_methods), rownames(m))]
			df_imports[names(lt_imports$n_import_methods), "importMethods"] = lt_imports$n_import_methods
		}
		if(length(lt_imports$n_import_classes)) {
			lt_imports$n_import_classes = lt_imports$n_import_classes[intersect(names(lt_imports$n_import_classes), rownames(m))]
			df_imports[names(lt_imports$n_import_classes), "importClasses"] = lt_imports$n_import_classes
		}
	}

	obj$df_imports = df_imports

	class(obj) = "pkgndep"

	obj$heaviness = heaviness(obj)
	return(obj)
}

pkg_exists = function(x) {
	system.file(package = x) != ""
}

parse_imports_from_namespace = function(x) {
	lib_dir = dirname(system.file(package = x))
	if(packageHasNamespace(x, lib_dir)) {
		ns_data = parseNamespaceFile(x, lib_dir)

		lt = ns_data$imports
		if(length(lt)) {
			lt1 = lt[!sapply(lt, is.list)]
			lt2 = lt[sapply(lt, is.list)]
			n_imports = tapply(seq_along(lt2), unlist(sapply(lt2, function(x) x[1])), 
				function(x) unique(unlist(lapply(lt2[x], function(y) y[2]))))
			n_imports = sapply(n_imports, length)
		} else {
			n_imports = NULL                
		}

		lt = ns_data$importMethods
		if(length(lt)) {
			lt1 = lt[!sapply(lt, is.list)]
			lt2 = lt[sapply(lt, is.list)]
			n_import_methods = tapply(seq_along(lt2), unlist(sapply(lt2, function(x) x[1])), 
				function(x) unique(unlist(lapply(lt2[x], function(y) y[2]))))
			n_import_methods = sapply(n_import_methods, length)
		} else {
			n_import_methods = NULL
		}


		lt = ns_data$importClasses
		if(length(lt)) {
			lt1 = lt[!sapply(lt, is.list)]
			lt2 = lt[sapply(lt, is.list)]
			n_import_classes = tapply(seq_along(lt2), unlist(sapply(lt2, function(x) x[1])), 
				function(x) unique(unlist(lapply(lt2[x], function(y) y[2]))))
			n_import_classes = sapply(n_import_classes, length)
		} else {
			n_import_classes = NULL
		}

		list(n_imports = n_imports, n_import_methods = n_import_methods, n_import_classes = n_import_classes)
	} else {
		NULL
	}
}

# == title
# Print method
#
# == param
# -x The object from `pkgndep`.
# -... Other arguments.
#
# == value
# No value is returned.
#
# == example
# # See examples in `pkgndep()`.
#
print.pkgndep = function(x, ...) {
	GetoptLong::qqcat("@{x$package} version @{x$version}\n")
	GetoptLong::qqcat("@{x$n_by_depends_imports} namespaces loaded if only loading packages in Depends and Imports\n")
	GetoptLong::qqcat("@{x$n_by_all} namespaces loaded after loading all packages in Depends, Imports and Suggests/Enhances\n")
}

# == title
# Loaded namespaces
#
# == param
# -x The object from `pkgndep`.
# -include_suggests Whether include the namespaces that are loaded if loading the packages from "Suggests" field.
#
# == value
# A vector of namespace names.
#
loaded_namespaces = function(x, include_suggests = TRUE) {
	m = x$m
	if(include_suggests) {
		sort(unique(c(rownames(m), colnames(m))))
	} else {
		l1 = x$pkg_category %in% c("Depends", "Imports")
		l2 = apply(m[l1, , drop = FALSE], 2, function(x) any(!is.na(x)))
		sort(unique(unlist(dimnames(m[l1, l2, drop = FALSE]))))
	}
}

# == title
# Which packages are listed in Depends/Imports
#
# == param
# -x The object from `pkgndep`.
#
# == value
# A vector of logical values.
#
which_imported = function(x) {
	x$pkg_category %in% c("Depends", "Imports")
}

# == title
# Unavailable packages
#
# == param
# -x The object from `pkgndep`.
#
# == details
# It lists the packages that are not installed in the "Suggests" field.
#
# == value
# A vector of package names.
#
unavailable_pkg = function(x) {
	sort(rownames(x$mat)[!x$pkg_available])
}

# == title
# Plot method
#
# == param
# -x The object from `pkgndep`.
# -pkg_fontsize Fontsize for the package names.
# -title_fontsize Fontsize for the titles.
# -legend_fontsize Fontsize for the legends.
# -fix_size Should the rows and columns in the heatmap have fixed size?
# -cex A factor multiplicated to all font sizes.
# -help Whether to print help message?
# -file A path of the figure. The size of the figure is automatically calculated.
# -res Resolution of the figure (only for png and jpeg).
# -... Other arguments.
#
# == details
# If ``fix_size`` is set to ``TRUE``. The size of the whole plot can be obtained by:
#
#     size = plot(x, fix_size = TRUE)
#
# where ``size`` is a numeric vector of length two which are the width and height of the whole heatmap.
# If ``file`` argument is set, the size of the figure is automatically calculated.
#
# If there are no dependency packages stored in ``x``, ``NULL`` is returned.
# 
# == value
# A vector of two numeric values (in inches) that correspond to the width and height of the plot.
#
# == example
# # See examples in `pkgndep()`.
#
plot.pkgndep = function(x, pkg_fontsize = 10*cex, title_fontsize = 12*cex, 
	legend_fontsize = 10*cex, fix_size = !dev.interactive(), cex = 1, 
	help = TRUE, file = NULL, res = 144, ...) {

	if(!is.null(file)) {
		if(grepl("\\.png$", file, ignore.case = TRUE)) {
			tmp_file = tempfile(fileext = ".png")
			png(tmp_file, width = 1000)
			size = plot(x, fix_size = TRUE, pkg_fontsize = pkg_fontsize, title_fontsize = title_fontsize,
				legend_fontsize = legend_fontsize, cex = cex, help = FALSE, file = NULL)
			dev.off()
			file.remove(tmp_file)

			if(!is.null(size)) {
				size[1] = max(size[1], 7)
				size[2] = max(size[2], 3)
				png(file, width = size[1], height = size[2], units = "in", res = res)
				plot(x, fix_size = TRUE, pkg_fontsize = pkg_fontsize, title_fontsize = title_fontsize,
					legend_fontsize = legend_fontsize, cex = cex, help = FALSE, file = NULL)
				dev.off()
			} else {
				png(file, width = 3, height = 1, units = "in", res = res)
				grid.text(qq("No dependency found for package '@{x$package}'"), 0.5, 0.5)
				dev.off()
			}

			return(invisible(NULL))
		} else if(grepl("\\.(jpg|jpeg)$", file, ignore.case = TRUE)) {
			tmp_file = tempfile()
			jpeg(tmp_file)
			size = plot(x, fix_size = TRUE, pkg_fontsize = pkg_fontsize, title_fontsize = title_fontsize,
				legend_fontsize = legend_fontsize, cex = cex, help = FALSE, file = NULL)
			dev.off()
			file.remove(tmp_file)

			if(!is.null(size)) {
				size[1] = max(size[1], 7)
				size[2] = max(size[2], 3)
				jpeg(file, width = size[1], height = size[2], units = "in", res = res)
				plot(x, fix_size = TRUE, pkg_fontsize = pkg_fontsize, title_fontsize = title_fontsize,
					legend_fontsize = legend_fontsize, cex = cex, help = FALSE, file = NULL)
				dev.off()
			} else {
				jpeg(file, width = 3, height = 1, units = "in", res = res)
				grid.text(qq("No dependency found for package '@{x$package}'"), 0.5, 0.5)
				dev.off()
			}

			return(invisible(NULL))
		} else if(grepl("\\.svg$", file, ignore.case = TRUE)) {
			tmp_file = tempfile()
			svg(tmp_file)
			size = plot(x, fix_size = TRUE, pkg_fontsize = pkg_fontsize, title_fontsize = title_fontsize,
				legend_fontsize = legend_fontsize, cex = cex, help = FALSE, file = NULL)
			dev.off()
			file.remove(tmp_file)

			if(requireNamespace("svglite", quietly = TRUE)) {
				svg_fun = svglite::svglite
			} else {
				svg_fun = svg
			}

			if(!is.null(size)) {
				size[1] = max(size[1], 7)
				size[2] = max(size[2], 3)
				svg_fun(file, width = size[1], height = size[2])
				plot(x, fix_size = TRUE, pkg_fontsize = pkg_fontsize, title_fontsize = title_fontsize,
					legend_fontsize = legend_fontsize, cex = cex, help = FALSE, file = NULL)
				dev.off()
			} else {
				svg_fun(file, width = 3, height = 1)
				grid.text(qq("No dependency found for package '@{x$package}'"), 0.5, 0.5)
				dev.off()
			}

			return(invisible(NULL))
		} else {
			stop("`file` only allows extensions of 'png/jpg/svg'.")
		}
	}

	get.gpar() # test whether the graphics window can be opened or not
	if(missing(fix_size) && cex != 1) {
		fix_size = TRUE
	}

	m = x$mat
	row_split = x$pkg_category

	if(ncol(m) == 0) {
		if(help) message(qq("No dependency found for package '@{x$package}'. Won't generate the plot.\n"))
		return(invisible(NULL))
	}

	# a rude way to move all packages which are attached by imported packages before those by suggested packages
	column_order_by = apply(m, 2, function(x) sum(!is.na(x)))
	l = row_split %in% c("Depends", "Imports")
	l2 = apply(m[l, ,drop = FALSE], 2, function(x) sum(!is.na(x))) > 0
	column_order_by[l2] = column_order_by[l2] + 10000
	column_order = order(column_order_by, decreasing = TRUE)

	line_height = grobHeight(textGrob("A", gp = gpar(fontsize = pkg_fontsize)))*1.5

	fix_size = fix_size
	ht = Heatmap(m, 
		name = x$package,
		row_split = row_split,
		column_split = ifelse(colnames(m) %in% BASE_PKGS, "Base packages", "Other packages"),
		heatmap_legend_param = list(nrow = 1, title = "", labels_gp = gpar(fontsize = legend_fontsize)), 
		rect_gp = gpar(col = "#EEEEEE"),
		show_row_dend = FALSE, 
		show_column_dend = FALSE,
		col = c("basePkgs" = "#e31a1c", "loadedOnly" = "#1f78b4", "otherPkgs" = "#33a02c"),
		# row_order = order(apply(m, 1, function(x) sum(!is.na(x)))),
		column_order = column_order,
		column_names_gp = gpar(fontsize = pkg_fontsize),
		column_names_rot = 60,
		row_names_gp = gpar(fontsize = pkg_fontsize),
		column_title_gp = gpar(fontsize = title_fontsize),
		row_title_gp = gpar(fontsize = title_fontsize),
		row_title_rot = 90,
		bottom_annotation = HeatmapAnnotation(loaded = ifelse(apply(m[which_imported(x), , drop = FALSE], 2, function(x) any(!is.na(x))), "yes", "no"),
			col = list(loaded = c("yes" = "purple", "no" = "white")), simple_anno_size = unit(1, "mm"), 
			show_legend = FALSE, show_annotation_name = FALSE),
		width = if(fix_size) ncol(m)*line_height else NULL,
		height = if(fix_size) nrow(m)*line_height else NULL,
		right_annotation = if(any(x$pkg_category %in% c("Imports", "Depends"))) {
			rowAnnotation(loaded2 = ifelse(x$pkg_category %in% c("Imports", "Depends"), "yes", "no"),
					col = list(loaded2 = c("yes" = "purple", "no" = "white")), simple_anno_size = unit(1, "mm"), 
					show_legend = FALSE, show_annotation_name = FALSE)
		} else {
			NULL
		}
	)

	ht = ht + rowAnnotation(n_pkg = anno_barplot(apply(m, 1, function(x) sum(!is.na(x))), width = unit(2, "cm"),
								axis_param = list(gp = gpar(fontsize = 8*cex)), gp = gpar(fill = "#808080", col = NA)),
			annotation_label = "Loaded\nnamespaces", annotation_name_rot = 60,
			annotation_name_gp = gpar(fontsize = pkg_fontsize),
			annotation_name_offset = unit(8, "mm"))

	df_imports = x$df_imports
	ht = ht + rowAnnotation("n_import" = anno_nimports_barplot(df_imports, x$pkg_category, width = unit(2, "cm"),
			gp = gpar(fill = c("#ff7f00", "#cab2d6", "#8dd3c7"), col = NA),
			axis_param = list(gp = gpar(fontsize = 8*cex))),
			annotation_label = "Imported\nmethods", annotation_name_rot = 60,
			annotation_name_gp = gpar(fontsize = pkg_fontsize),
			annotation_name_offset = unit(8, "mm"))

	lgd_list = list()
	if(any(rowSums(df_imports) > 0)) {
		if(all(df_imports[, 1] == 0 & df_imports[, 2] == 0)) {
			ind = 3
		} else if(all(df_imports[, 1] == 0 & df_imports[, 3] == 0)) {
			ind = 2
		} else if(all(df_imports[, 2] == 0 & df_imports[, 3] == 0)) {
			ind = 1
		} else if(all(df_imports[, 1] == 0)) {
			ind = 2:3
		} else if(all(df_imports[, 2] == 0)) {
			ind = c(1, 3)
		} else if(all(df_imports[, 3] == 0)) {
			ind = 1:2
		} else {
			ind = 1:3
		}
		lgd1 = Legend(title = "", at = c("imported functions", "imported S4 methods", "imported S4 classes")[ind], 
			nrow = 1, legend_gp = gpar(fill = c("#ff7f00", "#cab2d6", "#8dd3c7")[ind]), 
			labels_gp = gpar(fontsize = legend_fontsize))
		lgd_list = c(lgd_list, list(lgd1))
	}

	if(any(rowSums(df_imports)[x$pkg_category %in% c("Imports", "Depends")] == 0)) {
		lgd2 = Legend(title = "", at = c("imported whole namespace"), type = "lines",
			nrow = 1, legend_gp = gpar(lty = 2, col = "#808080"), grid_width = unit(0.6, "cm"), 
			labels_gp = gpar(fontsize = legend_fontsize))
		lgd_list = c(lgd_list, list(lgd2))
	}
	
	ht = ht + rowAnnotation(pkg = anno_text(rownames(m), 
			gp = gpar(fontsize = pkg_fontsize, 
				col = ifelse(x$pkg_available, "black", "#AAAAAA"),
				fontface = ifelse(x$pkg_available, "plain", 'italic'))))
	
	n_total1 = length(unique(c(rownames(x$m), colnames(x$m))))
	l1 = x$pkg_category %in% c("Depends", "Imports")
	l2 = apply(x$m[l1, , drop = FALSE], 2, function(x) any(!is.na(x)))
	n_total2 = length(unique(unlist(dimnames(x$m[l1, l2, drop = FALSE]))))
	ht = draw(ht, 
		heatmap_legend_side = "bottom", 
		adjust_annotation_extension = FALSE,
		column_title = GetoptLong::qq("In total @{n_total2} namespaces are loaded directly or indirectly (@{n_total1}) when loading '@{x$package}' (@{x$version})"),
		column_title_gp = gpar(fontsize = title_fontsize),
		heatmap_legend_list = lgd_list)

	w = convertWidth(ComplexHeatmap:::width(ht), "in", valueOnly = TRUE)
	h = convertHeight(ComplexHeatmap:::height(ht), "in", valueOnly = TRUE)

	if(fix_size && help) {
		ds = dev.size()
		if(w - ds[1] > 0.1 || h - ds[2] > 0.1) {
			message(paste0("The best device size to visualize the complete plot is ", 
				ceiling(w*100)/100, " x ", 
				ceiling(h*100)/100, " (in inches),\nor use plot(obj, fix_size = FALSE) so that heatmap cells are not in fixed sizes."))
		}
	}

	invisible(c(width = w, height = h))
}

scoreCol = function(x) {
	score = 0
	for(i in 1:length(x)) {
		if(!is.na(x[i])) {
			score = score + 2^(length(x)-i)
		}
	}
	return(score)
}

anno_nimports_barplot = function(x, category,
	bar_width = 0.6, ylim = NULL, axis = TRUE, gp = gpar(),
	axis_param = list(side = "top", labels_rot = 0),
	width = NULL, height = NULL, border = TRUE) {

	which = "row"

	anno_size = ComplexHeatmap:::anno_width_and_height(which, width, height, unit(2, "cm"))

	if(all(rowSums(x) == 0) && is.null(ylim)) ylim = c(0, 1)

	row_fun = function(index, k, n) {
		fun = anno_barplot(x, gp = gp, which = "row", ylim = ylim,
			baseline = 0, width = anno_size$width, border = border, bar_width = bar_width,
			axis = axis, axis_param = axis_param)@fun
		fun(index, k, n)

		if(category[index[1]] %in% c("Imports", "Depends")) {
			v = x[index, , drop = FALSE]
			l = rowSums(v) == 0
			if(any(l)) {
				n = length(index)
				pushViewport(viewport(xscale = c(0, 1), yscale = c(0.5, n + 0.5)))
				grid.segments(0, n - which(l) + 1, 1, n - which(l) + 1, gp = gpar(lty = 2, col = "#808080"), default.units = "native")
				popViewport()
			}
		}
	}

	fun = row_fun

	anno = AnnotationFunction(
		fun = fun,
		fun_name = "anno_barplot",
		which = which,
		width = anno_size$width,
		height = anno_size$height,
		var_import = list(x, category, border, bar_width, axis, axis_param, anno_size, ylim, gp)
	)
		
	anno@subsetable = TRUE

	data_scale = c(0, max(rowSums(x)))
	if(data_scale[2] == 0) data_scale[2] = 1

	axis_param = ComplexHeatmap:::validate_axis_param(axis_param, which)
	axis_grob = if(axis) ComplexHeatmap:::construct_axis_grob(axis_param, which, data_scale) else NULL
	anno@extended = ComplexHeatmap:::update_anno_extend(anno, axis_grob, axis_param)

	return(anno) 
}

dep = function(pkg, verbose = TRUE) {
	if(verbose) cat(silver("Loading"), green(pkg), silver("to a new R session... "))
		
	if(is.null(env$loaded_ns[[pkg]])) {
		
		tb = r(load_pkg, args = list(pkg = pkg), user_profile = FALSE)
		if(is.null(tb)) {
	    	if(verbose) cat(red(GetoptLong::qq("@{pkg} cannot be loaded.\n")))
	    	return(NULL)
	    } else {
	    	for(i in seq_len(ncol(tb))) {
	    		tb[, i] = as.vector(tb[, i])
	    	}
		    nr = nrow(tb)
		    if(verbose) cat(green(nr), silver(GetoptLong::qq("namespace@{ifelse(nr == 1, '', 's')} loaded.\n")))
		}
		env$loaded_ns[[pkg]] = tb
	} else {
		tb = env$loaded_ns[[pkg]]
		nr = nrow(tb)
		if(verbose) cat(green(nr), silver(GetoptLong::qq("namespace@{ifelse(nr == 1, '', 's')} loaded.\n")))
	}
    return(tb)
}

load_pkg = function(pkg) {
	tmp_file = tempfile()
	sink(tmp_file)
	oe = try(suppressWarnings(suppressPackageStartupMessages(tm <- system.time(library(pkg, character.only = TRUE)))), silent = TRUE)
	sink()
	unlink(tmp_file)

	if(inherits(oe, "try-error")) {
		cat("\n")
	} else {
		foo = sessionInfo()
		df1 = data.frame(pkg = foo$basePkgs, type = rep("basePkgs", length(foo$basePkgs)))
		df2 = data.frame(pkg = names(foo$loadedOnly), type = rep("loadedOnly", length(foo$loadedOnly)))
		df3 = data.frame(pkg = names(foo$otherPkgs), type = rep("otherPkgs", length(foo$otherPkgs)))
		df = base::rbind(df1, df2, df3)
		df = df[df[, 1] != pkg ,]
		df$tm = tm[3]
		print(df, row.names = FALSE)
	}
}

# == title
# Heaviness of a dependent package
#
# == param
# -x An object returned by `pkgndep`.
# -rel Whether to return the absolute measure or the relative measure.
# -a A contant added for calculating the relative measure.
#
# == details
# The heaviness of a dependent package is calculated as follows. If package B is in the "Depends/Imports" fields of package A,
# which means, package B will be loaded when loading package A, denote ``v1`` as the total namespaces when loading package A,
# and ``v2`` as the total number of namespaces if moving package B to "Suggests" (which means, now B is not loaded when loading A).
# The absolute measure is simply ``v1 -  v2`` and relative measure is ``(v1 + a)/(v2 + a)``. 
#
# In the second scenario, if B is in the "Suggests/Enhances" fields of package A, now ``v2`` is the total number of namespaces if moving
# B to "Depends/Imports", the absolute measure is ``v2 - v1`` and relative measure is ``(v2 + a)/(v1 + a)``.
#
# == value
# A numeric vector.
#
# == example
# x = readRDS(system.file("extdata", "x.rds", package = "pkgndep"))
# heaviness(x)
# heaviness(x, rel = TRUE)
heaviness = function(x, rel = FALSE, a = 10) {
	m = x$m[x$pkg_category %in% c("Imports", "Depends"), , drop = FALSE]
	nm = rownames(m)

	v1 = sum(apply(m, 2, function(x) any(!is.na(x))))
	v = numeric(0)
	for(i in seq_along(nm)) {
		v2 = sum(apply(m[rownames(m) != nm[i], , drop = FALSE], 2, function(x) any(!is.na(x))))
		if(rel) {
			v[i] = (v1 + a)/(v2 + a)
		} else {
			v[i] = v1 - v2
		}
	}
	names(v) = nm

	mi = x$m[!x$pkg_category %in% c("Imports", "Depends"), , drop = FALSE]
	nm = rownames(mi)
	vi = numeric(0)
	for(i in seq_along(nm)) {
		v2 = sum(apply(x$m[c(rownames(m), nm[i]), , drop = FALSE], 2, function(x) any(!is.na(x))))
		if(rel) {
			vi[i] = (v2 + a)/(v1 + a)
		} else {
			vi[i] = v2 - v1
		}
	}
	names(vi) = nm

	v = c(v, vi)
	v[rownames(x$m)]
}

# == title
# Gini index on the heaviness
#
# == param
# -x An object returned by `pkgndep`.
# -a A constant add to heaviness.
#
gini_index = function(x, a = 2) {
	l = x$pkg_category %in% c("Imports", "Depends")
	if(sum(l) < 2) {
		0
	} else {
		v = x$heaviness[l] + a
		v = sort(v)
		n = length(v)
        s = 2 * sum(v * 1:n)/(n * sum(v)) - 1 - (1/n)
        s = n/(n - 1)*s
        max(0, s)
	}
}


env = new.env()
env$loaded_ns = list()

.onAttach = function(libname, pkgname) {
    env$loaded_ns = list()
}


BASE_PKGS = c("base", "compiler", "datasets", "graphics", "grDevices", "grid", "methods",
		"parallel", "splines", "stats", "stats4", "tcltk", "tools", "utils")
	