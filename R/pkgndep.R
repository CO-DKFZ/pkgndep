# == title
# Number of Dependency Packages
#
# == param
# -pkg Package name or the path of the package.
# -verbose Whether print messages. 
#
# == details
# For each package listed in the "Depends", "Imports" and "Suggests" (or also "Enhances") fields
# in the DESCRIPTION file, this function opens a new R session, loads the package
# and counts the number of namespaces that are loaded.
#
# == value
# A ``pkgndep`` object.
#
# == example
# \donttest{
# x = pkgndep("ComplexHeatmap")
# }
# # The `x` variable generated by `pkgndep()` is already saved in this package.
# x = readRDS(system.file("extdata", "ComplexHeatmap_dep.rds", package = "pkgndep"))
# x
# plot(x)
# 
pkgndep = function(pkg, verbose = TRUE) {

	if(verbose) {
		cat(blue(GetoptLong::qq("========== checking @{pkg} ==========\n")))
	}
	if(file.exists(pkg)) {
		x = read.dcf(paste0(pkg, "/DESCRIPTION"))
		x = as.data.frame(x)
	} else {
		if(!pkg_exists(pkg)) {
			stop(paste0("Package '", pkg, "' cannot be found."))
		}
		x = packageDescription(pkg)
	}

	if(is.null(x$Depends)) {
		depends = character(0)
	} else {
		depends = x$Depends
		depends = gsub("\\s*\\(.*?\\)", "", depends)
		depends = strsplit(depends, "\\s*,\\s*")[[1]]
		depends = depends[depends != "R"]
	}

	if(is.null(x$Imports)) {
		imports = character(0)
	} else {
		imports = x$Imports
		imports = gsub("\\s*\\(.*?\\)", "", imports)
		imports = strsplit(imports, "\\s*,\\s*")[[1]]

		imports = setdiff(imports, depends)
	}

	if(is.null(x$Suggests)) {
		suggests = character(0)
	} else {
		suggests = x$Suggests
		suggests = gsub("\\s*\\(.*?\\)", "", suggests)
		suggests = strsplit(suggests, "\\s*,\\s*")[[1]]
	}

	if(is.null(x$Enhances)) {
		enhances = character(0)
		has_enhances = FALSE
	} else {
		enhances = x$Enhances
		enhances = gsub("\\s*\\(.*?\\)", "", enhances)
		enhances = strsplit(enhances, "\\s*,\\s*")[[1]]
		has_enhances = TRUE
	}

	suggests = c(suggests, enhances)

	dep_lt = lapply(depends, dep, verbose)
	names(dep_lt) = depends
	imp_lt = lapply(imports, dep, verbose)
	names(imp_lt) = imports
	sug_lt = lapply(suggests, dep, verbose)
	names(sug_lt) = suggests

	all_pkg = c(depends, imports, suggests)

	if(length(all_pkg) == 0) {
		obj = list(
			package = x$Package,
			version = x$Version,
			mat = matrix(nrow = 0, ncol = 0), 
			pkg_category = character(0),
			which_imported = logical(0),
			which_imported_but_not_loaded = logical(0),
			which_suggsted_but_also_loaded = logical(0),
			which_enhanced = logical(0),
			pkg_available = logical(0),
			loading_time = numeric(0),
			n_by_depends_imports = 0,
			n_by_all = 0,
			bioc = !is.null(x$biocViews),
			df_imports = NULL,
			heaviness = numeric(0)
		)

		class(obj) = "pkgndep"
		return(obj)
	}

	dep_lt2 = dep_lt[!sapply(dep_lt, is.null)]
	imp_lt2 = imp_lt[!sapply(imp_lt, is.null)]
	sug_lt2 = sug_lt[!sapply(sug_lt, is.null)]

	all_pkg_dep = unique(unlist(c(lapply(dep_lt2, function(x) x[, 1]), 
		                          lapply(imp_lt2, function(x) x[, 1]), 
		                          lapply(sug_lt2, function(x) x[, 1]))))

	m = matrix(NA, nrow = length(all_pkg), ncol = length(all_pkg_dep), dimnames = list(all_pkg, all_pkg_dep))
	tm = numeric(nrow(m))
	names(tm) = rownames(m)
	for(nm in names(dep_lt2)) {
		y = structure(dep_lt2[[nm]][, 2], names = dep_lt2[[nm]][, 1])
		m[nm, names(y)] = y
		tm[nm] = dep_lt2[[nm]][, 3][1]
	}
	for(nm in names(imp_lt2)) {
		y = structure(imp_lt2[[nm]][, 2], names = imp_lt2[[nm]][, 1])
		m[nm, names(y)] = y
		tm[nm] = imp_lt2[[nm]][, 3][1]
	}
	for(nm in names(sug_lt2)) {
		y = structure(sug_lt2[[nm]][, 2], names = sug_lt2[[nm]][, 1])
		m[nm, names(y)] = y
		tm[nm] = sug_lt2[[nm]][, 3][1]
	}

	if(has_enhances) {
		pkg_category = c(rep("Depends", length(dep_lt)), rep("Imports", length(imports)), rep("Suggests or\nEnhances", length(suggests)))
	} else {
		pkg_category = c(rep("Depends", length(dep_lt)), rep("Imports", length(imports)), rep("Suggests", length(suggests)))
	}
	names(pkg_category) = rownames(m)
	pkg_available = !sapply(c(dep_lt, imp_lt, sug_lt), is.null)

	row_order = order(pkg_category, apply(m, 1, function(x) sum(!is.na(x))))

	# a rude way to move all packages which are attached by imported packages before those by suggested packages
	column_order_by = apply(m, 2, function(x) sum(!is.na(x)))
	l = pkg_category %in% c("Depends", "Imports")
	l2 = apply(m[l, ,drop = FALSE], 2, function(x) sum(!is.na(x))) > 0
	column_order_by[l2] = column_order_by[l2] + 10000
	column_order = order(column_order_by, -apply(m[row_order, , drop = FALSE], 2, function(x) which(!is.na(x))[1]), decreasing = TRUE)

	m = m[row_order, column_order, drop = FALSE]
	pkg_category = pkg_category[row_order]
	pkg_available = pkg_available[row_order]
	tm = tm[row_order]

	df_imports = matrix(0, nrow = nrow(m), ncol = 3)
	colnames(df_imports) = c("imports", "importMethods", "importClasses")
	rownames(df_imports) = rownames(m)

	lt_imports = parse_imports_from_namespace(x$Package)
	if(!is.null(lt_imports)) {
		if(length(lt_imports$n_imports)) {
			lt_imports$n_imports = lt_imports$n_imports[intersect(names(lt_imports$n_imports), rownames(m))]
			df_imports[names(lt_imports$n_imports), "imports"] = lt_imports$n_imports
		}
		if(length(lt_imports$n_import_methods)) {
			lt_imports$n_import_methods = lt_imports$n_import_methods[intersect(names(lt_imports$n_import_methods), rownames(m))]
			df_imports[names(lt_imports$n_import_methods), "importMethods"] = lt_imports$n_import_methods
		}
		if(length(lt_imports$n_import_classes)) {
			lt_imports$n_import_classes = lt_imports$n_import_classes[intersect(names(lt_imports$n_import_classes), rownames(m))]
			df_imports[names(lt_imports$n_import_classes), "importClasses"] = lt_imports$n_import_classes
		}
	}

	not_used = setdiff(rownames(df_imports), c(unlist(lapply(lt_imports, names)), rownames(m)[!pkg_category %in% c("Depends", "Imports")]))
	if(length(not_used)) {
		df_imports[not_used, 1] = -Inf
	}

	tb = r(load_pkg, args = list(pkg = x$Package), user_profile = FALSE)

	obj = list(
		package = x$Package,
		version = x$Version,
		mat = m, 
		pkg_category = pkg_category,
		which_imported = pkg_category %in% c("Depends", "Imports"),
		which_imported_but_not_loaded = is.infinite(df_imports[, 1]) & !(rownames(df_imports) %in% tb$pkg),
		which_suggested_but_also_loaded = rownames(m) %in% tb$pkg & !(pkg_category %in% c("Depends", "Imports")),
		which_enhanced = rownames(m) %in% enhances,
		pkg_available = pkg_available,
		loading_time = tm,
		n_by_depends_imports = 0,
		n_by_all = 0,
		bioc = !is.null(x$biocViews),
		df_imports = df_imports
	)

	class(obj) = "pkgndep"

	obj$n_by_depends_imports = length(loaded_namespaces(obj, FALSE))
	obj$n_by_all = length(loaded_namespaces(obj, TRUE))
	obj$heaviness = heaviness(obj)
	return(obj)
}

pkg_exists = function(x) {
	system.file(package = x) != ""
}

parse_imports_from_namespace = function(x) {
	lib_dir = dirname(system.file(package = x))
	if(packageHasNamespace(x, lib_dir)) {
		ns_data = parseNamespaceFile(x, lib_dir)

		lt = ns_data$imports
		if(length(lt)) {
			lt1 = lt[!sapply(lt, is.list)]
			lt2 = lt[sapply(lt, is.list)]
			n_imports = tapply(seq_along(lt2), unlist(sapply(lt2, function(x) x[1])), 
				function(x) unique(unlist(lapply(lt2[x], function(y) y[2]))))
			n_imports = sapply(n_imports, length)
			if(length(n_imports)) {
				sign = tapply(seq_along(lt2), unlist(sapply(lt2, function(x) x[1])), 
					function(x) unique(unlist(lapply(lt2[x], function(y) names(y)[2]))))
				sign = sapply(sign, function(x) ifelse(identical(x, "except"), -1, 1))
				n_imports = n_imports * sign
			} else {
			  n_imports = NULL
			}
			n_imports = c(n_imports, structure(rep(0, length(lt1)), names = unlist(lt1)))
		} else {
			n_imports = NULL                
		}

		lt = ns_data$importMethods
		if(length(lt)) {
			lt1 = lt[!sapply(lt, is.list)]
			lt2 = lt[sapply(lt, is.list)]
			n_import_methods = tapply(seq_along(lt2), unlist(sapply(lt2, function(x) x[1])), 
				function(x) unique(unlist(lapply(lt2[x], function(y) y[2]))))
			n_import_methods = sapply(n_import_methods, length)
			if(length(n_import_methods) == 0) n_import_methods = NULL
			n_import_methods = c(n_import_methods, structure(rep(0, length(lt1)), names = unlist(lt1)))
		} else {
			n_import_methods = NULL
		}


		lt = ns_data$importClasses
		if(length(lt)) {
			lt1 = lt[!sapply(lt, is.list)]
			lt2 = lt[sapply(lt, is.list)]
			n_import_classes = tapply(seq_along(lt2), unlist(sapply(lt2, function(x) x[1])), 
				function(x) unique(unlist(lapply(lt2[x], function(y) y[2]))))
			n_import_classes = sapply(n_import_classes, length)
			if(length(n_import_classes) == 0) n_import_classes = NULL
			n_import_classes = c(n_import_classes, structure(rep(0, length(lt1)), names = unlist(lt1)))
		} else {
			n_import_classes = NULL
		}

		list(n_imports = n_imports, n_import_methods = n_import_methods, n_import_classes = n_import_classes)
	} else {
		NULL
	}
}

# == title
# Print method
#
# == param
# -x An object from `pkgndep`.
# -... Other arguments.
#
# == value
# No value is returned.
#
# == example
# # See examples in `pkgndep()`.
#
print.pkgndep = function(x, ...) {
	GetoptLong::qqcat("@{x$package}, version @{x$version}\n")
	GetoptLong::qqcat("@{x$n_by_depends_imports} namespaces loaded if only loading packages in Depends and Imports\n")
	if(any(x$which_enhanced)) {
		GetoptLong::qqcat("@{x$n_by_all} namespaces loaded after loading all packages in Depends, Imports and Suggests/Enhances\n")
	} else {
		GetoptLong::qqcat("@{x$n_by_all} namespaces loaded after loading all packages in Depends, Imports and Suggests\n")
	}
}

# == title
# Loaded namespaces
#
# == param
# -x An object from `pkgndep`.
# -include_all Whether to include the namespaces that are loaded if also loading packages from "Suggests"/"Enhances" field.
#
# == value
# A vector of namespace names.
#
loaded_namespaces = function(x, include_all = FALSE) {
	m = x$mat
	if(nrow(m) == 0) {
		return(NULL)
	}
	if(include_all) {
		unique(c(rownames(m), colnames(m)))
	} else {
		l1 = x$which_imported & !x$which_imported_but_not_loaded
		l2 = apply(m[l1, , drop = FALSE], 2, function(x) any(!is.na(x)))
		unique(unlist(dimnames(m[l1, l2, drop = FALSE])))
	}
}

# == title
# Unavailable packages
#
# == param
# -x An object from `pkgndep`.
#
# == details
# It lists the packages that are not installed in the "Suggests" field.
#
# == value
# A vector of package names.
#
unavailable_packages = function(x) {
	rownames(x$mat)[!x$pkg_available]
}

# == title
# Package category
#
# == param
# -x An object from `pkgndep`.
#
# == value
# A vector of the category of dependency packages.
pkg_category = function(x) {
	cate = x$pkg_category
	cate[x$which_enhanced] = "Enhances"
	cate
}
